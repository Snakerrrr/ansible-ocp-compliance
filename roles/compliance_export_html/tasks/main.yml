---
# Rol: compliance_export_html
# Responsabilidad: Exportar resultados de compliance desde PVCs a HTML
# Se ejecuta desde el HUB y puede acceder a managed clusters usando kubeconfig

- name: Verificar que oc está disponible
  ansible.builtin.command: oc version --client
  register: oc_version
  changed_when: false
  failed_when: false

- name: Verificar si el kubeconfig está configurado
  ansible.builtin.shell: |
    oc config view --minify --raw 2>&1 || echo "NO_KUBECONFIG"
  register: kubeconfig_check
  changed_when: false
  failed_when: false
  when: oc_version.rc == 0

- name: Determinar si se puede usar oc para buscar secrets
  ansible.builtin.set_fact:
    can_use_oc: "{{ oc_version.rc == 0 and kubeconfig_check.stdout is defined and 'NO_KUBECONFIG' not in kubeconfig_check.stdout }}"
  when: oc_version.rc == 0

- name: Advertir si oc no está disponible o no tiene kubeconfig
  ansible.builtin.debug:
    msg: |
      ADVERTENCIA: El comando 'oc' no está disponible o no tiene kubeconfig configurado.
      
      El playbook intentará usar métodos alternativos para obtener el kubeconfig:
      1. Secrets de ACM usando módulos de Ansible (si están disponibles)
      2. Variables managed_cluster_kubeconfigs
      3. Archivos locales en /tmp/kubeconfig-*
      
      Si ejecutas desde AAP, asegúrate de:
      - Configurar una credencial de tipo "OpenShift or Kubernetes API Bearer Token"
      - O configurar el kubeconfig en el proyecto de AAP
  when: oc_version.rc != 0 or (kubeconfig_check.stdout is defined and 'NO_KUBECONFIG' in kubeconfig_check.stdout)

- name: DEBUG - Verificar contexto recibido
  ansible.builtin.debug:
    msg:
      - "=========================================="
      - "CONTEXTO RECIBIDO EN EL ROL"
      - "=========================================="
      - "target_cluster_context (raw): {{ target_cluster_context | default('NO_DEFINIDO') }}"
      - "managed_cluster_name (raw): {{ managed_cluster_name | default('NO_DEFINIDO') }}"
      - "inventory_hostname: {{ inventory_hostname }}"
      - "=========================================="

- name: Establecer variables iniciales básicas
  ansible.builtin.set_fact:
    # CRÍTICO: No usar default('') aquí - si viene del orchestrator, debe tener valor
    # Si no viene definido, entonces sí usar default
    target_cluster_context: "{{ target_cluster_context if target_cluster_context is defined else '' }}"
    managed_cluster_name: "{{ managed_cluster_name if managed_cluster_name is defined else (target_cluster_context if target_cluster_context is defined else '') }}"

- name: Establecer kubeconfig_secret_namespace (valor por defecto basado en managed_cluster_name)
  ansible.builtin.set_fact:
    kubeconfig_secret_namespace: "{{ managed_cluster_name if (target_cluster_context != '' and managed_cluster_name != '') else 'openshift-compliance' }}"

- name: Establecer managed_cluster_kubeconfigs (siempre usar diccionario vacío por defecto)
  ansible.builtin.set_fact:
    _managed_cluster_kubeconfigs: "{{ {} }}"

- name: Establecer lista de nombres de secrets de ACM
  ansible.builtin.set_fact:
    acm_secret_names: "{{ ['admin-kubeconfig', managed_cluster_name + '-import', managed_cluster_name + '-bootstrap-sa-token'] }}"

- name: Buscar secret admin-kubeconfig en el Hub (Nativo - Prioridad 1)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ managed_cluster_name }}"
    name: admin-kubeconfig
  register: hub_admin_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Buscar secret de importación (Fallback - Prioridad 2)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ managed_cluster_name }}"
    name: "{{ managed_cluster_name }}-import"
  register: hub_import_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Validar hallazgos de secrets
  ansible.builtin.set_fact:
    found_admin_secret: "{{ hub_admin_secret.resources | default([]) | length > 0 }}"
    found_import_secret: "{{ hub_import_secret.resources | default([]) | length > 0 }}"
  when: target_cluster_context != ''

- name: Extraer kubeconfig desde admin-kubeconfig (Prioridad 1)
  ansible.builtin.set_fact:
    kubeconfig_from_admin:
      stdout: "{{ hub_admin_secret.resources[0].data.kubeconfig | b64decode }}"
      rc: 0
      secret_namespace: "{{ hub_admin_secret.resources[0].metadata.namespace }}"
      secret_name: "{{ hub_admin_secret.resources[0].metadata.name }}"
  when:
    - target_cluster_context != ''
    - found_admin_secret | default(false) | bool
    - hub_admin_secret.resources | default([]) | length > 0
    - hub_admin_secret.resources[0].data.kubeconfig is defined

- name: Guardar kubeconfig desde admin-kubeconfig a archivo temporal
  ansible.builtin.copy:
    content: "{{ kubeconfig_from_admin.stdout }}"
    dest: "/tmp/kubeconfig-{{ managed_cluster_name }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - found_admin_secret | default(false) | bool
    - kubeconfig_from_admin.stdout is defined
    - kubeconfig_from_admin.stdout != ''
    - kubeconfig_from_admin.stdout | length > 100

- name: Extraer import.yaml del secret de importación (Prioridad 2)
  ansible.builtin.set_fact:
    import_yaml_b64: "{{ hub_import_secret.resources[0].data['import.yaml'] }}"
    import_yaml_raw:
      stdout: "{{ hub_import_secret.resources[0].data['import.yaml'] | b64decode }}"
      rc: 0
  when:
    - target_cluster_context != ''
    - found_import_secret | default(false) | bool
    - hub_import_secret.resources[0].data['import.yaml'] is defined

- name: Inicializar variables si no se encontraron secrets
  ansible.builtin.set_fact:
    kubeconfig_from_admin:
      stdout: ""
      rc: 1
    import_yaml_raw:
      stdout: ""
      rc: 1
  when:
    - target_cluster_context != ''
    - not (found_admin_secret | default(false) | bool)
    - not (found_import_secret | default(false) | bool)

- name: Advertir si no se encontraron secrets de kubeconfig
  ansible.builtin.debug:
    msg: |
      No se encontraron secrets de kubeconfig en el namespace '{{ managed_cluster_name }}'.
      
      Secrets buscados:
      1. admin-kubeconfig (prioridad alta)
      2. {{ managed_cluster_name }}-import (fallback)
      
      El playbook continuará con métodos alternativos:
      - Variables managed_cluster_kubeconfigs
      - Archivos locales en /tmp/kubeconfig-*
  when:
    - target_cluster_context != ''
    - not (found_admin_secret | default(false) | bool)
    - not (found_import_secret | default(false) | bool)

- name: Establecer ruta del archivo temporal import.yaml
  ansible.builtin.set_fact:
    import_yaml_file: "/tmp/import-{{ managed_cluster_name }}.yaml"
  when: target_cluster_context != ''

- name: Guardar import.yaml en archivo temporal
  ansible.builtin.copy:
    content: "{{ import_yaml_raw.stdout }}"
    dest: "{{ import_yaml_file }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100

- name: Crear script temporal para extraer kubeconfig
  ansible.builtin.template:
    src: extract-kubeconfig.sh.j2
    dest: "/tmp/extract-kubeconfig-{{ managed_cluster_name }}.sh"
    mode: '0755'
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100

- name: Extraer kubeconfig desde bootstrap-hub-kubeconfig en import.yaml
  ansible.builtin.command: "/tmp/extract-kubeconfig-{{ managed_cluster_name }}.sh {{ import_yaml_file }}"
  register: kubeconfig_from_import
  changed_when: false
  failed_when: false
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100


- name: Determinar kubeconfig final desde secrets de ACM (priorizar admin-kubeconfig sobre bootstrap-hub-kubeconfig)
  ansible.builtin.set_fact:
    kubeconfig_from_acm_secret: "{{ kubeconfig_from_admin if (kubeconfig_from_admin.stdout is defined and kubeconfig_from_admin.stdout != '' and kubeconfig_from_admin.stdout | length > 100) else (kubeconfig_from_import if (kubeconfig_from_import.stdout is defined and kubeconfig_from_import.stdout != '' and kubeconfig_from_import.stdout | length > 100) else {'rc': 1, 'stdout': ''}) }}"
  when: target_cluster_context != ''

- name: Buscar kubeconfig en secret personalizado (fallback)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ kubeconfig_secret_namespace }}"
    name: "managed-cluster-kubeconfig-{{ managed_cluster_name }}"
  register: hub_custom_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Extraer kubeconfig desde secret personalizado
  ansible.builtin.set_fact:
    kubeconfig_from_custom_secret:
      stdout: "{{ hub_custom_secret.resources[0].data.kubeconfig | b64decode }}"
      rc: 0
  when:
    - target_cluster_context != ''
    - hub_custom_secret.resources | default([]) | length > 0
    - hub_custom_secret.resources[0].data.kubeconfig is defined

- name: Marcar kubeconfig personalizado como no encontrado
  ansible.builtin.set_fact:
    kubeconfig_from_custom_secret:
      stdout: ""
      rc: 1
  when:
    - target_cluster_context != ''
    - hub_custom_secret.resources | default([]) | length == 0

- name: Determinar qué secret se usó
  ansible.builtin.set_fact:
    kubeconfig_from_secret: "{{ kubeconfig_from_acm_secret if (kubeconfig_from_acm_secret.rc == 0 and kubeconfig_from_acm_secret.stdout != '' and kubeconfig_from_acm_secret.stdout | length > 100) else (kubeconfig_from_custom_secret if (kubeconfig_from_custom_secret.rc == 0 and kubeconfig_from_custom_secret.stdout != '' and kubeconfig_from_custom_secret.stdout | length > 100) else {'rc': 1, 'stdout': ''}) }}"
    secret_source: "{{ 'admin_kubeconfig' if (kubeconfig_from_admin.stdout is defined and kubeconfig_from_admin.stdout != '' and kubeconfig_from_admin.stdout | length > 100) else ('bootstrap_hub_kubeconfig' if (kubeconfig_from_import.stdout is defined and kubeconfig_from_import.stdout != '' and kubeconfig_from_import.stdout | length > 100) else ('custom' if (kubeconfig_from_custom_secret.rc == 0 and kubeconfig_from_custom_secret.stdout != '' and kubeconfig_from_custom_secret.stdout | length > 100) else 'none')) }}"
  when: target_cluster_context != ''

- name: Guardar kubeconfig desde secret a archivo temporal
  ansible.builtin.copy:
    content: "{{ kubeconfig_from_secret.stdout }}"
    dest: "/tmp/kubeconfig-{{ managed_cluster_name }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - secret_source != 'none'
    - kubeconfig_from_secret.stdout is defined
    - kubeconfig_from_secret.stdout != ''
    - kubeconfig_from_secret.stdout | length > 100

- name: Determinar ruta del kubeconfig del managed cluster (fallback a archivo local)
  ansible.builtin.set_fact:
    managed_cluster_kubeconfig_path: "{{ ('/tmp/kubeconfig-' + managed_cluster_name) if (target_cluster_context != '' and secret_source != 'none') else (_managed_cluster_kubeconfigs[managed_cluster_name] if (target_cluster_context != '' and _managed_cluster_kubeconfigs is defined and managed_cluster_name in _managed_cluster_kubeconfigs) else ('/tmp/kubeconfig-' + managed_cluster_name if target_cluster_context != '' else '')) }}"
    oc_context_arg: ""
    is_managed_cluster: "{{ target_cluster_context != '' }}"
    kubeconfig_source: "{{ secret_source if (target_cluster_context != '' and secret_source != 'none') else ('file' if (target_cluster_context != '' and _managed_cluster_kubeconfigs is defined and managed_cluster_name in _managed_cluster_kubeconfigs) else ('default_file' if target_cluster_context != '' else 'none')) }}"
  when: target_cluster_context != ''

- name: Verificar si existe kubeconfig en archivo (fallback)
  ansible.builtin.stat:
    path: "{{ managed_cluster_kubeconfig_path }}"
  register: kubeconfig_exists
  when:
    - target_cluster_context != ''
    - managed_cluster_kubeconfig_path != ''
    - kubeconfig_source is defined
    - kubeconfig_source != 'acm_native'
    - kubeconfig_source != 'custom'

- name: Verificar validez del kubeconfig
  ansible.builtin.shell: |
    KUBECONFIG="{{ managed_cluster_kubeconfig_path }}" oc whoami &>/dev/null && echo "valid" || echo "invalid"
  register: kubeconfig_validity
  changed_when: false
  failed_when: false
  when:
    - target_cluster_context != ''
    - (kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists)

- name: Advertir si el kubeconfig está expirado
  ansible.builtin.debug:
    msg: |
      El kubeconfig para '{{ target_cluster_context }}' está expirado o inválido.
      
      {% if kubeconfig_source == 'acm_native' %}
      El kubeconfig viene de un secret nativo de ACM (admin-kubeconfig o {{ managed_cluster_name }}-import).
      ACM debería renovarlo automáticamente. Si persiste el problema, verifica:
        oc get secret admin-kubeconfig -n {{ managed_cluster_name }}
        oc get secret {{ managed_cluster_name }}-import -n {{ managed_cluster_name }}
      {% elif kubeconfig_source == 'custom' %}
      Para renovarlo, actualiza el secret personalizado:
        ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }}
      {% else %}
      Para renovarlo:
      1. Loguearte al managed cluster: oc login <api-server-url>
      2. Exportar nuevo kubeconfig: oc config view --minify --raw > {{ managed_cluster_kubeconfig_path }}
      3. Ajustar permisos: chmod 600 {{ managed_cluster_kubeconfig_path }}
      4. (Opcional) Guardar en secret: ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }} {{ managed_cluster_kubeconfig_path }}
      {% endif %}
  when:
    - target_cluster_context != ''
    - (kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists)
    - kubeconfig_validity.stdout == "invalid"

- name: Fallar si no se puede acceder al managed cluster
  ansible.builtin.fail:
    msg: |
      No se encontró kubeconfig para el managed cluster '{{ target_cluster_context }}'.
      
      El playbook buscó en:
      1. Secrets nativos de ACM en namespace '{{ managed_cluster_name }}':
         - admin-kubeconfig
         - {{ managed_cluster_name }}-import
         - Cualquier secret con "kubeconfig" en el nombre
      
      2. Secret personalizado: managed-cluster-kubeconfig-{{ managed_cluster_name }} en namespace '{{ kubeconfig_secret_namespace }}'
      
      3. Variable managed_cluster_kubeconfigs
      
      4. Archivo: /tmp/kubeconfig-{{ target_cluster_context }}
      
      Soluciones:
      - Verificar que el namespace '{{ managed_cluster_name }}' existe: oc get namespace {{ managed_cluster_name }}
      - Listar secrets disponibles: oc get secrets -n {{ managed_cluster_name }}
      - Si no hay secret nativo, crear uno: ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }}
      - Si los PVCs están en el Hub, no especifiques target_cluster_context
  when:
    - target_cluster_context != ''
    - not ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))

- name: Mostrar método de acceso al cluster
  ansible.builtin.debug:
    msg: |
      ========================================
      Método de Acceso al Cluster
      ========================================
      Cluster/Ambiente: {{ managed_cluster_name if target_cluster_context != '' else 'HUB (contexto actual)' }}
      Fuente: {{ kubeconfig_source if target_cluster_context != '' else 'Contexto actual (HUB)' }}
      Kubeconfig: {{ managed_cluster_kubeconfig_path if (target_cluster_context != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else 'Contexto actual (HUB)' }}
      {% if kubeconfig_source == 'acm_native' %}
      Secret nativo de ACM en namespace: {{ managed_cluster_name }}
      Secrets buscados: admin-kubeconfig, {{ managed_cluster_name }}-import
      {% elif kubeconfig_source == 'custom' %}
      Secret personalizado: managed-cluster-kubeconfig-{{ managed_cluster_name }} en namespace {{ kubeconfig_secret_namespace }}
      {% endif %}
      ========================================
  when: target_cluster_context != ''

- name: Verificar que oscap está disponible
  ansible.builtin.command: oscap --version
  register: oscap_check
  changed_when: false
  failed_when: false

- name: Fallar si oscap no está disponible
  ansible.builtin.fail:
    msg: "oscap (openscap-scanner) no está disponible. Instalar con: yum install openscap-scanner"
  when: oscap_check.rc != 0

- name: Verificar que bzip2 está disponible
  ansible.builtin.command: which bunzip2 || which bzip2
  register: bzip2_check
  changed_when: false
  failed_when: false

- name: Advertir si bzip2 no está disponible
  ansible.builtin.debug:
    msg: "Advertencia: bunzip2/bzip2 no está disponible. Los archivos .bzip2 no se podrán descomprimir automáticamente."
  when: bzip2_check.rc != 0

- name: Verificar que zip está disponible
  ansible.builtin.command: which zip
  register: zip_check
  changed_when: false
  failed_when: false

- name: Advertir si zip no está disponible
  ansible.builtin.debug:
    msg: "Advertencia: zip no está disponible. No se podrá crear el archivo ZIP. Instalar con: sudo apt-get install zip"
  when: zip_check.rc != 0

- name: Crear directorio de salida (organizado por cluster)
  ansible.builtin.file:
    path: "{{ compliance_reports_path }}"
    state: directory
    mode: '0755'
    recurse: yes

- name: Buscar PVCs de compliance
  ansible.builtin.command: oc get pvc -n openshift-compliance {{ oc_context_arg | default('') }} --no-headers -o custom-columns=NAME:.metadata.name
  register: pvc_list
  changed_when: false
  environment: "{{ {'KUBECONFIG': managed_cluster_kubeconfig_path} if (target_cluster_context != '' and managed_cluster_kubeconfig_path is defined and managed_cluster_kubeconfig_path != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else {} }}"

- name: Filtrar PVCs permitidos (solo estándares específicos con soporte para sufijos de nodos)
  ansible.builtin.set_fact:
    filtered_pvcs: "{{ pvc_list.stdout_lines | select('match', '^(ocp4-pci-dss-4-0$|ocp4-pci-dss-node-4-0-|ocp4-cis-1-7$|ocp4-cis-node-1-7-)') | list }}"

- name: Separar PVCs CIS y PCI
  ansible.builtin.set_fact:
    cis_pvcs: "{{ filtered_pvcs | select('match', '^ocp4-cis') | list }}"
    pci_pvcs: "{{ filtered_pvcs | select('match', '^ocp4-pci-dss') | list }}"

- name: Mostrar PVCs encontrados
  ansible.builtin.debug:
    msg: |
      ========================================
      PVCs Encontrados en {{ managed_cluster_name if target_cluster_context != '' else 'HUB' }}
      ========================================
      PVCs CIS: {{ cis_pvcs | length }} - {{ cis_pvcs if cis_pvcs | length > 0 else 'Ninguno' }}
      PVCs PCI: {{ pci_pvcs | length }} - {{ pci_pvcs if pci_pvcs | length > 0 else 'Ninguno' }}
      ========================================
      
      VERIFICACIÓN: Asegúrate de que estos nombres coincidan con los PVCs que inspeccionaste manualmente.
      Si no coinciden, verifica que los scans de compliance hayan completado correctamente.

- name: Establecer valores finales para sub-tareas
  ansible.builtin.set_fact:
    _final_managed_cluster_kubeconfig_path: "{{ managed_cluster_kubeconfig_path if (target_cluster_context != '' and managed_cluster_kubeconfig_path is defined and managed_cluster_kubeconfig_path != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else '' }}"
    _final_oc_context_arg: "{{ oc_context_arg | default('') }}"

- name: Procesar cada PVC CIS
  when: cis_pvcs | length > 0
  ansible.builtin.include_tasks: process_pvc.yml
  loop: "{{ cis_pvcs }}"
  loop_control:
    loop_var: pvc_item
    label: "{{ pvc_item }}"
  vars:
    pvc_name: "{{ pvc_item }}"
    pvc_type: "cis"
    oc_context_arg: "{{ _final_oc_context_arg }}"
    managed_cluster_kubeconfig_path: "{{ _final_managed_cluster_kubeconfig_path }}"

- name: Procesar cada PVC PCI
  when: pci_pvcs | length > 0
  ansible.builtin.include_tasks: process_pvc.yml
  loop: "{{ pci_pvcs }}"
  loop_control:
    loop_var: pvc_item
    label: "{{ pvc_item }}"
  vars:
    pvc_name: "{{ pvc_item }}"
    pvc_type: "pci"
    oc_context_arg: "{{ _final_oc_context_arg }}"
    managed_cluster_kubeconfig_path: "{{ _final_managed_cluster_kubeconfig_path }}"

# --- TAREAS DE PREPARACIÓN DE DATOS (Descomprimir y Aplanar) ---

- name: Descomprimir archivos .bzip2 (Recursivo en todas las carpetas de PVC)
  ansible.builtin.shell: |
    find "{{ compliance_reports_path }}" -type d -name "ocp4-*" | while read pvc_dir; do
      if [ -d "$pvc_dir" ]; then
        echo "Descomprimiendo archivos en: $pvc_dir"
        find "$pvc_dir" -name "*.bzip2" -exec bunzip2 -f {} \; 2>/dev/null || true
      fi
    done
  args:
    executable: /bin/bash
  ignore_errors: true
  register: decompression_result

- name: Aplanar estructura de directorios (Mover XMLs de subdirectorios a la raíz de cada PVC)
  ansible.builtin.shell: |
    find "{{ compliance_reports_path }}" -type d -name "ocp4-*" | while read pvc_dir; do
      if [ -d "$pvc_dir" ]; then
        echo "Aplanando XMLs en: $pvc_dir"
        # Buscar XMLs en subdirectorios (mindepth 2) y moverlos a la raíz del PVC
        find "$pvc_dir" -name "*.xml" -mindepth 2 -type f -exec mv {} "$pvc_dir/" \; 2>/dev/null || true
      fi
    done
  args:
    executable: /bin/bash
  ignore_errors: true
  register: flatten_result

- name: Renderizar script de conversión XML → HTML
  ansible.builtin.template:
    src: render_reports.sh.j2
    dest: "{{ compliance_reports_path }}/render_reports.sh"
    mode: '0755'

- name: Ejecutar conversión XML → HTML
  ansible.builtin.command: "{{ compliance_reports_path }}/render_reports.sh"
  args:
    chdir: "{{ compliance_reports_path }}"
  register: render_script_output
  changed_when: render_script_output.rc == 0
  failed_when: false

- name: Verificar archivos HTML generados
  ansible.builtin.find:
    paths: "{{ compliance_reports_path }}"
    patterns: "*.html"
    recurse: true
  register: html_files

- name: Generar summary.txt
  ansible.builtin.template:
    src: summary.txt.j2
    dest: "{{ compliance_reports_path }}/summary.txt"
    mode: '0644'
  vars:
    cis_pvcs: "{{ cis_pvcs }}"
    pci_pvcs: "{{ pci_pvcs }}"
    compliance_reports_path: "{{ compliance_reports_path }}"

# --- DEBUG: Ubicación del reporte (entrega la hace el orquestador vía GitLab) ---
- name: DEBUG - Reporte generado (ZIP listo para orquestador/GitLab)
  ansible.builtin.debug:
    msg:
      - "Ruta de reportes: {{ compliance_reports_path }}"
      - "Cluster context: {{ target_cluster_context | default(inventory_hostname) }}"
      - "El orquestador consolidará los ZIPs y los subirá a GitLab si do_push_gitlab está activo."

# --- EMPAQUETADO (ZIP para uso por orquestador o descarga local) ---

- name: Buscar archivos HTML y summary para comprimir
  ansible.builtin.find:
    paths: "{{ compliance_reports_path }}"
    patterns: 
      - "*.html"       # Solo HTMLs (excluimos XML pesados)
      - "summary.txt"   # El resumen
    recurse: yes        # Busca en todas las subcarpetas (3/, 4/, 5/, etc.)
    file_type: file
  register: files_to_zip

- name: Comprimir reportes HTML y Resumen en un ZIP
  community.general.archive:
    path: "{{ files_to_zip.files | map(attribute='path') | list }}"
    dest: "{{ compliance_reports_path }}/compliance_reports_{{ target_cluster_context | default(inventory_hostname) }}_{{ ansible_date_time.epoch }}.zip"
    format: zip
    mode: '0644'
  register: zip_creation
  when: 
    - files_to_zip is defined
    - files_to_zip.files | length > 0

# --- ENTREGA DE REPORTES ---
# La entrega (GitLab push) se realiza en el orquestador (orchestrator_aap_multicluster.yml).
# Este rol solo genera el ZIP en compliance_reports_path; el orquestador lo recoge y sube al repo.
