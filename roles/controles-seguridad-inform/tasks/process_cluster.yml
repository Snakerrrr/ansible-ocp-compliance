---
# ---------------------------------------------------------
# CONEXIÓN HUB-TO-SPOKE: Extraer kubeconfig del managed cluster desde el Hub
# ---------------------------------------------------------
- name: "[CONN] Obtener kubeconfig del managed cluster desde el Hub (admin-kubeconfig)"
  when: target_cluster_name is defined and target_cluster_name | length > 0
  delegate_to: localhost
  block:
    - name: Extraer secret admin-kubeconfig del namespace del spoke en el Hub
      ansible.builtin.shell: |
        oc get secret admin-kubeconfig -n {{ target_cluster_name }} -o jsonpath='{.data.kubeconfig}' 2>&1 | base64 -d || echo ""
      register: kubeconfig_from_hub
      changed_when: false
      failed_when: false

    - name: Guardar kubeconfig a archivo temporal
      ansible.builtin.copy:
        content: "{{ kubeconfig_from_hub.stdout }}"
        dest: "/tmp/kubeconfig-{{ target_cluster_name }}"
        mode: '0600'
      when:
        - kubeconfig_from_hub.stdout is defined
        - kubeconfig_from_hub.stdout != ''
        - kubeconfig_from_hub.stdout | length > 100

    - name: Establecer ruta del kubeconfig dinámico
      ansible.builtin.set_fact:
        dynamic_kubeconfig_path: "/tmp/kubeconfig-{{ target_cluster_name }}"
      when:
        - kubeconfig_from_hub.stdout is defined
        - kubeconfig_from_hub.stdout != ''
        - kubeconfig_from_hub.stdout | length > 100

# Verificar que el kubeconfig existe en el controlador y exponer la ruta al host que ejecuta las tareas
# (evita que las tareas usen el contexto por defecto = Hub cuando la extracción falla)
- name: "[CONN] Verificar que el kubeconfig del spoke existe en el controlador"
  ansible.builtin.stat:
    path: "/tmp/kubeconfig-{{ target_cluster_name }}"
  register: kubeconfig_file_stat
  delegate_to: localhost
  when: target_cluster_name is defined and target_cluster_name | length > 0

- name: "[CONN] Fallar si no se pudo extraer el kubeconfig del spoke"
  ansible.builtin.fail:
    msg: |
      No se pudo obtener el kubeconfig del cluster '{{ target_cluster_name }}' desde el Hub.
      Verifique:
      1) Credencial del HUB ACM asociada al Job Template (debe permitir 'oc' contra el Hub).
      2) El secret admin-kubeconfig existe en el namespace '{{ target_cluster_name }}' en el Hub:
         oc get secret admin-kubeconfig -n {{ target_cluster_name }}
      3) Los nombres en survey_target_clusters coinciden con los nombres de los namespaces de los managed clusters en el Hub.
  when:
    - target_cluster_name is defined
    - target_cluster_name | length > 0
    - not kubeconfig_file_stat.stat.exists | default(false)

- name: "[CONN] Exponer ruta del kubeconfig al host que ejecuta las tareas"
  ansible.builtin.set_fact:
    dynamic_kubeconfig_path: "/tmp/kubeconfig-{{ target_cluster_name }}"
  when:
    - target_cluster_name is defined
    - target_cluster_name | length > 0
    - kubeconfig_file_stat.stat.exists | default(false)

- name: "[CONN] Debug - Cluster y kubeconfig a usar"
  ansible.builtin.debug:
    msg: "Cluster: {{ target_cluster_name | default('N/A') }} | Kubeconfig: {{ dynamic_kubeconfig_path | default('contexto por defecto') }}"
  when: target_cluster_name is defined

- name: "[INIT] Obtener infraestructura del cluster"
  kubernetes.core.k8s_info:
    api_version: config.openshift.io/v1
    kind: Infrastructure
    name: cluster
    kubeconfig: "{{ dynamic_kubeconfig_path | default(omit) }}"
  register: infra_info

- name: "[INIT] Definir variables de ejecución"
  ansible.builtin.set_fact:
    cluster_name: "{{ infra_info.resources[0].status.infrastructureName | default('DESCONOCIDO') }}"

# SECCIÓN INFORM 

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 01_kubeadmin.yml
  when: "'ALL' in report_name or 'kubeadmin' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 02_log_forwarder.yml
  when: "'ALL' in report_name or 'logs' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 03_ingress_tls.yml
  when: "'ALL' in report_name or 'ingress' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 04_ldap_tls.yml
  when: "'ALL' in report_name or 'ldap' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 05_acs_sensor.yml
  when: "'ALL' in report_name or 'acs' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 06_network_policies.yml
  when: "'ALL' in report_name or 'network' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: 07_oauth_timeouts_inform.yml
  when: "'ALL' in report_name or 'oauth' in report_name"

- name: "[INFORM] Ejecutando revisiones de seguridad"
  ansible.builtin.include_tasks: automatic_remediation_inform.yml
  when: "'ALL' in report_name or 'remediation' in report_name"

# FINALIZACION

- name: "[REPORT] Generar y enviar reporte consolidado"
  ansible.builtin.include_tasks: 99_send_report.yml

# ---------------------------------------------------------
# LIMPIEZA: Borrar kubeconfig temporal por seguridad
# ---------------------------------------------------------
- name: "[CLEANUP] Eliminar kubeconfig temporal"
  ansible.builtin.file:
    path: "{{ dynamic_kubeconfig_path }}"
    state: absent
  when:
    - dynamic_kubeconfig_path is defined
    - dynamic_kubeconfig_path | length > 0
  delegate_to: localhost
