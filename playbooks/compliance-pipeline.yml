---
# Playbook Unificado: compliance-pipeline.yml
# ENTRYPOINT √∫nico para toda la automatizaci√≥n de compliance OCP
#
# Flags de control:
#   do_gitops: true|false  - Ejecutar GitOps (toggle + commit + push)
#   do_export_html: true|false - Exportar resultados a HTML
#
# Casos de uso:
#   1. Solo activar scans (GitOps):
#      ansible-playbook playbooks/compliance-pipeline.yml -i inventories/localhost.yml \
#        -e "github_token=XXX do_gitops=true do_export_html=false"
#
#   2. Solo exportar HTML (healthcheck):
#      ansible-playbook playbooks/compliance-pipeline.yml -i inventories/localhost.yml \
#        -e "do_gitops=false do_export_html=true"
#
#   3. Pipeline completo:
#      ansible-playbook playbooks/compliance-pipeline.yml -i inventories/localhost.yml \
#        -e "github_token=XXX do_gitops=true do_export_html=true"

- name: Compliance Pipeline OCP (CIS + PCI DSS)
  hosts: localhost
  gather_facts: true

  vars:
    # =========================
    # Git / GitOps configuration (defaults)
    # =========================
    github_user: "Snakerrrr"
    gitops_repo_branch: "main"
    gitops_repo_path: "/tmp/acm-policies"

    # =========================
    # Compliance behavior (defaults)
    # =========================
    run_cis: true
    run_pci: true
    scan_remediation_action: "inform"
    install_operator_remediation_action: "enforce"
    
    # =========================
    # ScanSetting configuration (defaults)
    # =========================
    # Schedule en formato cron para escaneos peri√≥dicos
    # Ejemplo: "0 2 * * *" = Todos los d√≠as a las 2:00 AM (default)
    # Ejemplo: "0 */6 * * *" = Cada 6 horas
    scan_schedule: "0 2 * * *"
    scan_setting_name: "periodic-daily"
    
    # =========================
    # ACM Placement configuration (defaults)
    # =========================
    # Label selector para determinar en qu√© cluster(s) aplicar las pol√≠ticas
    # Por defecto usa: compliance=enabled (mejor pr√°ctica - etiqueta funcional)
    # Ejemplo alternativo: placement_label_key=environment, placement_label_value=cluster-acs
    placement_label_key: "compliance"
    placement_label_value: "enabled"
    # Usar matchLabels (m√°s simple) en lugar de matchExpressions por defecto
    placement_use_matchlabels: true
    
    # =========================
    # Cluster context for export (defaults)
    # =========================
    # Cuando se ejecuta desde el HUB, especificar el contexto del cluster objetivo
    # Ejemplo: target_cluster_context=cluster-acs
    # Si est√° vac√≠o, se usa el contexto actual
    target_cluster_context: ""
    
    # =========================
    # Kubeconfig Secret Configuration (defaults)
    # =========================
    # Namespace donde se almacenan los secrets con kubeconfigs de managed clusters
    # El playbook buscar√° autom√°ticamente el secret: managed-cluster-kubeconfig-{target_cluster_context}
    # en este namespace. Si no existe, usar√° fallback a archivos locales.
    kubeconfig_secret_namespace: "openshift-compliance"
    
    # =========================
    # Managed Cluster Kubeconfigs (defaults)
    # =========================
    # Diccionario con las rutas de los kubeconfigs de los managed clusters
    # Formato: { "cluster-name": "/ruta/al/kubeconfig" }
    # Ejemplo:
    #   managed_cluster_kubeconfigs:
    #     cluster-acs: "/tmp/kubeconfig-cluster-acs"
    #     cluster-2: "/tmp/kubeconfig-cluster-2"
    # Si no se especifica, se buscar√° en /tmp/kubeconfig-{target_cluster_context}
    managed_cluster_kubeconfigs: {}

    # =========================
    # Export HTML configuration (defaults)
    # =========================
    export_output_dir: "/tmp/compliance-reports"

    # =========================
    # Email configuration (defaults)
    # =========================
    # Configuraci√≥n para env√≠o de reportes por correo electr√≥nico
    # Requiere: servidor SMTP accesible o Gmail/Outlook con App Password
    do_send_email: false
    email_smtp_host: "smtp.gmail.com"
    email_smtp_port: 587
    email_smtp_username: "bsoto@redhat.com"
    email_smtp_password: "swtgocesdjeasgbx"
    email_to: "bsoto@redhat.com"
    email_from: "jmunozag@redhat.com"
    email_subject_prefix: "Reporte de Compliance"

    # =========================
    # Control flags (defaults)
    # =========================
    do_gitops: false
    do_export_html: false

  tasks:
    - name: Establecer valores finales de variables
      set_fact:
        _github_user: "{{ github_user | default('Snakerrrr') }}"
        _github_token: "{{ github_token | default('') }}"
        _gitops_repo_branch: "{{ gitops_repo_branch | default('main') }}"
        _gitops_repo_path: "{{ gitops_repo_path | default('/tmp/acm-policies') }}"
        _run_cis: "{{ run_cis if run_cis is defined else true }}"
        _run_pci: "{{ run_pci if run_pci is defined else true }}"
        _scan_remediation_action: "{{ scan_remediation_action | default('inform') }}"
        _install_operator_remediation_action: "{{ install_operator_remediation_action | default('enforce') }}"
        _do_gitops: "{{ do_gitops | default(false) | bool }}"
        _do_export_html: "{{ do_export_html | default(false) | bool }}"
        _do_send_email: "{{ do_send_email | default(false) | bool }}"
        _gitops_repo_url: "https://{{ github_user | default('Snakerrrr') }}:{{ github_token | default('') }}@github.com/{{ github_user | default('Snakerrrr') }}/acm-policies.git"
        _scan_schedule: "0 1 * * *"
        _scan_setting_name: default
        _placement_label_key: compliance
        _placement_label_value: enabled
        _placement_use_matchlabels: true

    - name: Actualizar placement_label_key si est√° definido
      set_fact:
        _placement_label_key: "{{ placement_label_key }}"
      when:
        - placement_label_key is defined
        - placement_label_key | length > 0

    - name: Actualizar placement_label_value si est√° definido
      set_fact:
        _placement_label_value: "{{ placement_label_value }}"
      when:
        - placement_label_value is defined
        - placement_label_value | length > 0

    - name: Actualizar placement_use_matchlabels si est√° definido
      set_fact:
        _placement_use_matchlabels: "{{ placement_use_matchlabels | bool }}"
      when: placement_use_matchlabels is defined

    - name: Establecer directorio de salida con nombre de cluster (multicluster)
      set_fact:
        _export_output_dir: "{{ (export_output_dir | default('/tmp/compliance-reports')) + '/' + target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else (export_output_dir | default('/tmp/compliance-reports')) }}"

    - name: Validar flags de control
      fail:
        msg: "Al menos uno de los flags debe estar activado: do_gitops o do_export_html"
      when: not _do_gitops and not _do_export_html

    - name: Determinar ambiente/cluster actual
      set_fact:
        _current_cluster: "{{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else 'HUB (contexto actual)' }}"
        _current_context: "{{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else 'default' }}"

    - name: Mostrar configuraci√≥n del pipeline
      debug:
        msg: |
          ========================================
          Configuraci√≥n del Compliance Pipeline
          ========================================
          üåç Ambiente/Cluster: {{ _current_cluster }}
          do_gitops: {{ _do_gitops }}
          do_export_html: {{ _do_export_html }}
          run_cis: {{ _run_cis }}
          run_pci: {{ _run_pci }}
          scan_remediation_action: {{ _scan_remediation_action }}
          placement_label: {{ _placement_label_key }}={{ _placement_label_value }}
          target_cluster_context: {{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else '(contexto actual - HUB)' }}
          ========================================

    # ============================================================
    # FASE 1: GitOps (toggle policies + commit + push)
    # ============================================================
    - name: Ejecutar GitOps (toggle + commit + push)
      when: _do_gitops | bool
      block:
        - name: Validar que github_token est√° definido para GitOps
          fail:
            msg: "github_token es requerido cuando do_gitops=true"
          when: _github_token == "" or github_token is not defined

        - name: Actualizar scan_schedule si est√° definido
          set_fact:
            _scan_schedule: "{{ scan_schedule }}"
          when: 
            - scan_schedule is defined
            - scan_schedule | length > 0

        - name: Actualizar scan_setting_name si est√° definido
          set_fact:
            _scan_setting_name: "{{ scan_setting_name }}"
          when: 
            - scan_setting_name is defined
            - scan_setting_name | length > 0

        - name: Ejecutar rol gitops_policy_update
          include_role:
            name: gitops_policy_update
          vars:
            github_user: "{{ _github_user }}"
            github_token: "{{ _github_token }}"
            gitops_repo_path: "{{ _gitops_repo_path }}"
            gitops_repo_branch: "{{ _gitops_repo_branch }}"
            run_cis: "{{ _run_cis }}"
            run_pci: "{{ _run_pci }}"
            scan_remediation_action: "{{ _scan_remediation_action }}"
            install_operator_remediation_action: "{{ _install_operator_remediation_action }}"
            placement_label_key: "{{ _placement_label_key }}"
            placement_label_value: "{{ _placement_label_value }}"
            placement_use_matchlabels: "{{ _placement_use_matchlabels }}"
            scan_schedule: "{{ _scan_schedule }}"
            scan_setting_name: "{{ _scan_setting_name }}"

        - name: Informar que GitOps se complet√≥
          debug:
            msg: "GitOps completado. ArgoCD sincronizar√° autom√°ticamente los cambios."

    # ============================================================
    # FASE 2: Esperar instalaci√≥n y completaci√≥n (nuevos clusters)
    # ============================================================
    - name: Esperar instalaci√≥n del operador y completaci√≥n de scans
      when: _do_gitops | bool and _do_export_html | bool
      block:
        - name: Establecer target_cluster_context para compliance_wait (sin recursi√≥n)
          set_fact:
            _compliance_wait_target_cluster_context: "{{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else '' }}"

        - name: Ejecutar rol compliance_wait
          include_role:
            name: compliance_wait
          vars:
            target_cluster_context: "{{ _compliance_wait_target_cluster_context }}"
            # Todas las variables de espera se establecen en el rol si no est√°n definidas
            # No usar default() aqu√≠ para evitar recursi√≥n
            # scan_max_age_days: d√≠as m√°ximos antes de reiniciar scans (default: 30)
            # managed_cluster_kubeconfig_path se establece en el rol si no est√° definido

        - name: Informar que la espera se complet√≥
          debug:
            msg: "Espera completada. El operador est√° instalado y los scans han finalizado."

    # ============================================================
    # FASE 3: Export HTML (healthcheck informativo)
    # ============================================================
    - name: Ejecutar exportaci√≥n HTML
      when: _do_export_html | bool
      block:
        - name: Establecer target_cluster_context para compliance_export_html (sin recursi√≥n)
          set_fact:
            _export_html_target_cluster_context: "{{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else '' }}"

        - name: Ejecutar rol compliance_export_html
          include_role:
            name: compliance_export_html
          vars:
            export_output_dir: "{{ _export_output_dir }}"
            target_cluster_context: "{{ _export_html_target_cluster_context }}"
            # managed_cluster_kubeconfigs se establece en el rol si no est√° definido
            # No usar default() aqu√≠ para evitar recursi√≥n

        - name: Informar que exportaci√≥n se complet√≥
          debug:
            msg: "Exportaci√≥n HTML completada. Reportes disponibles en: {{ _export_output_dir }}"

    # ============================================================
    # FASE 4: Env√≠o de reportes por correo electr√≥nico
    # ============================================================
    # NOTA: En AAP, los Pods son ef√≠meros. Los archivos en /tmp se pierden
    # al finalizar el job. Esta fase env√≠a los reportes por correo antes
    # de que el Pod se destruya.
    - name: Enviar reportes por correo electr√≥nico
      when: 
        - _do_export_html | bool
        - _do_send_email | bool
      block:
        - name: Verificar disponibilidad del m√≥dulo mail
          command: python3 -c "import smtplib; import email"
          register: mail_module_check
          changed_when: false
          failed_when: false

        - name: Advertir si el m√≥dulo mail no est√° disponible
          debug:
            msg: |
              ‚ö†Ô∏è  ADVERTENCIA: El m√≥dulo mail de Ansible no est√° disponible.
              
              El m√≥dulo mail requiere las librer√≠as Python:
              - smtplib (normalmente incluida en Python est√°ndar)
              - email (normalmente incluida en Python est√°ndar)
              
              En AAP, aseg√∫rate de que tu Execution Environment tenga Python
              con estas librer√≠as disponibles.
              
              El env√≠o de correo se omitir√°.
          when: mail_module_check.rc != 0

        - name: Validar configuraci√≥n de correo
          fail:
            msg: |
              Configuraci√≥n de correo incompleta. Se requieren:
              - email_smtp_host
              - email_smtp_username
              - email_smtp_password
              - email_to
              - email_from (opcional, se usar√° email_smtp_username si no se especifica)
              
              En AAP, puedes configurar estas variables como:
              - Variables de entorno en el Job Template
              - Extra Variables en el Job Template
              - Secrets en AAP (recomendado para passwords)
          when: >
            (email_smtp_host is not defined or email_smtp_host == "") or
            (email_smtp_username is not defined or email_smtp_username == "") or
            (email_smtp_password is not defined or email_smtp_password == "") or
            (email_to is not defined or email_to == "")

        - name: Establecer valores de correo con defaults (priorizar variables de entorno en AAP)
          set_fact:
            # En AAP, las credenciales pueden venir de variables de entorno o Extra Variables
            _email_smtp_host: "{{ email_smtp_host | default(lookup('env', 'EMAIL_SMTP_HOST', default='')) }}"
            _email_smtp_port: "{{ email_smtp_port | default(lookup('env', 'EMAIL_SMTP_PORT', default='587')) | int }}"
            _email_smtp_username: "{{ email_smtp_username | default(lookup('env', 'EMAIL_SMTP_USERNAME', default='')) }}"
            _email_smtp_password: "{{ email_smtp_password | default(lookup('env', 'EMAIL_SMTP_PASSWORD', default='')) }}"
            _email_to: "{{ email_to | default(lookup('env', 'EMAIL_TO', default='')) }}"
            _email_from: "{{ email_from | default(email_smtp_username | default(lookup('env', 'EMAIL_FROM', default=''))) }}"
            _email_subject_prefix: "{{ email_subject_prefix | default('Reporte de Compliance') }}"
          when: mail_module_check.rc == 0

        - name: Buscar archivo ZIP generado
          find:
            paths: "{{ _export_output_dir }}"
            patterns: "compliance-reports-*.zip"
            file_type: file
          register: zip_files
          failed_when: false

        - name: Buscar archivo summary.txt
          find:
            paths: "{{ _export_output_dir }}"
            patterns: "summary.txt"
            file_type: file
          register: summary_files
          failed_when: false

        - name: Determinar archivo ZIP a enviar
          set_fact:
            zip_file_to_send: "{{ zip_files.files[0].path if (zip_files.files is defined and zip_files.files | length > 0) else '' }}"
            summary_file_to_send: "{{ summary_files.files[0].path if (summary_files.files is defined and summary_files.files | length > 0) else '' }}"

        - name: Advertir si no se encontr√≥ archivo ZIP
          debug:
            msg: |
              ‚ö†Ô∏è  No se encontr√≥ archivo ZIP en {{ _export_output_dir }}.
              El correo se enviar√° sin adjuntos.
          when: zip_file_to_send == ""

        - name: Construir asunto del correo
          set_fact:
            email_subject: "{{ _email_subject_prefix }} - {{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else 'HUB' }} - {{ ansible_date_time.date }}"

        - name: Construir cuerpo del correo
          set_fact:
            email_body: |
              Reporte de Compliance generado exitosamente.
              
              Detalles:
              - Cluster: {{ target_cluster_context if (target_cluster_context is defined and target_cluster_context != '') else 'HUB (contexto actual)' }}
              - Fecha: {{ ansible_date_time.iso8601 }}
              - Directorio: {{ _export_output_dir }}
              
              {% if zip_file_to_send != '' %}
              - Archivo ZIP adjunto: {{ zip_file_to_send | basename }}
              {% endif %}
              
              {% if summary_file_to_send != '' %}
              - Summary adjunto: {{ summary_file_to_send | basename }}
              {% endif %}
              
              Este correo fue generado autom√°ticamente por el Compliance Pipeline de Ansible.

        - name: Enviar reporte por correo (con ZIP si existe)
          mail:
            host: "{{ _email_smtp_host }}"
            port: "{{ _email_smtp_port }}"
            username: "{{ _email_smtp_username }}"
            password: "{{ _email_smtp_password }}"
            to: "{{ _email_to }}"
            from: "{{ _email_from }}"
            subject: "{{ email_subject }}"
            body: "{{ email_body }}"
            attach:
              - "{{ zip_file_to_send }}"
            secure: starttls
          when: 
            - mail_module_check.rc == 0
            - zip_file_to_send != ""
          ignore_errors: true
          register: email_result_zip

        - name: Enviar reporte por correo (solo summary si no hay ZIP)
          mail:
            host: "{{ _email_smtp_host }}"
            port: "{{ _email_smtp_port }}"
            username: "{{ _email_smtp_username }}"
            password: "{{ _email_smtp_password }}"
            to: "{{ _email_to }}"
            from: "{{ _email_from }}"
            subject: "{{ email_subject }}"
            body: "{{ email_body }}"
            attach:
              - "{{ summary_file_to_send }}"
            secure: starttls
          when: 
            - mail_module_check.rc == 0
            - zip_file_to_send == ""
            - summary_file_to_send != ""
          ignore_errors: true
          register: email_result_summary

        - name: Enviar reporte por correo (sin adjuntos si no hay archivos)
          mail:
            host: "{{ _email_smtp_host }}"
            port: "{{ _email_smtp_port }}"
            username: "{{ _email_smtp_username }}"
            password: "{{ _email_smtp_password }}"
            to: "{{ _email_to }}"
            from: "{{ _email_from }}"
            subject: "{{ email_subject }}"
            body: "{{ email_body }}"
            secure: starttls
          when: 
            - mail_module_check.rc == 0
            - zip_file_to_send == ""
            - summary_file_to_send == ""
          ignore_errors: true
          register: email_result_no_attach

        - name: Verificar resultado del env√≠o de correo
          set_fact:
            email_sent_successfully: >
              (email_result_zip is defined and email_result_zip.failed == false) or
              (email_result_summary is defined and email_result_summary.failed == false) or
              (email_result_no_attach is defined and email_result_no_attach.failed == false)

        - name: Informar que correo se envi√≥ exitosamente
          debug:
            msg: |
              ‚úÖ Correo enviado exitosamente a {{ _email_to }}
              Asunto: {{ email_subject }}
              {% if zip_file_to_send != '' %}
              Archivo adjunto: {{ zip_file_to_send | basename }}
              {% elif summary_file_to_send != '' %}
              Archivo adjunto: {{ summary_file_to_send | basename }}
              {% endif %}
          when: 
            - mail_module_check.rc == 0
            - email_sent_successfully | default(false) | bool

        - name: Advertir si el env√≠o de correo fall√≥
          debug:
            msg: |
              ‚ö†Ô∏è  El env√≠o de correo fall√≥. Verifica:
              1. Que el m√≥dulo mail est√© disponible en el Execution Environment
              2. Que las credenciales SMTP sean correctas
              3. Que el servidor SMTP sea accesible desde AAP
              4. Que el puerto SMTP no est√© bloqueado por firewall
              
              Los reportes est√°n disponibles en: {{ _export_output_dir }}
              (Nota: En AAP, estos archivos se perder√°n cuando el Pod termine)
          when: 
            - mail_module_check.rc == 0
            - not (email_sent_successfully | default(false) | bool)

    # ============================================================
    # Resumen final
    # ============================================================
    - name: Resumen final del pipeline
      debug:
        msg: |
          ========================================
          Compliance Pipeline - Ejecuci√≥n Completada
          ========================================
          GitOps ejecutado: {{ _do_gitops }}
          Export HTML ejecutado: {{ _do_export_html }}
          Correo enviado: {{ _do_send_email if (_do_export_html and _do_send_email) else false }}
          ========================================

