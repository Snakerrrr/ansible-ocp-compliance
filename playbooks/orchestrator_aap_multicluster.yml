---
- name: Orquestador Multi-Cluster AAP (Compliance)
  hosts: localhost
  connection: local
  gather_facts: true
  vars:
    # --- CONFIGURACIÓN ESTRUCTURAL (Sin datos de usuario) ---
    # Solo dejamos rutas temporales que no dependen del usuario
    export_output_dir: "/tmp/compliance-reports"
    gitops_repo_path: "/tmp/acm-policies"  # Ruta fija temporal, sin recursión
    
    # Defaults de seguridad (para que no falle si no se pasan)
    do_gitops: false
    do_export_html: false
    do_push_gitlab: false
    git_workdir: "/tmp/compliance-reports-git"
    
  tasks:
    # ---------------------------------------------------------
    # 1. NORMALIZACIÓN DE CREDENCIALES (Desde Environment Variables)
    # ---------------------------------------------------------
    # Las Environment Variables de AAP se inyectan como variables de entorno del SO
    # Necesitamos hacer el "puente" para convertirlas en variables de Ansible
    # IMPORTANTE: Esto debe ejecutarse ANTES de las validaciones para que las validaciones
    # puedan verificar las variables normalizadas
    - name: Normalizar credenciales desde Environment Variables
      ansible.builtin.set_fact:
        # Credenciales GitLab desde Environment Variables (si están definidas)
        gitlab_token: "{{ lookup('env', 'GITLAB_TOKEN') | default(gitlab_token | default('')) }}"
        gitlab_user: "{{ lookup('env', 'GITLAB_USER') | default(gitlab_user | default('')) }}"
        # Credenciales GitHub desde Environment Variables (si están definidas)
        github_token: "{{ lookup('env', 'GITHUB_TOKEN') | default(github_token | default('')) }}"
        github_user: "{{ lookup('env', 'GITHUB_USER') | default(github_user | default('')) }}"
      when: true  # Siempre ejecutar para normalizar

    # ---------------------------------------------------------
    # 2. VALIDACIÓN DE INPUTS (Semáforo de Seguridad)
    # ---------------------------------------------------------
    - name: Validar variables obligatorias de infraestructura Git
      ansible.builtin.assert:
        that:
          - github_user is defined
          - github_user | length > 0
          - gitops_repo_branch is defined
          - gitops_repo_branch | length > 0
          - github_token is defined
          - github_token | length > 0
        fail_msg: "ERROR: Faltan variables de Git. Defínalas en AAP (Extra Vars, Survey, Environment Variables o Credential de Source Control)."
      when: do_gitops | bool

    - name: Validar variables obligatorias de GitLab
      ansible.builtin.assert:
        that:
          - gitlab_repo_url is defined
          - gitlab_repo_url | length > 0
          - gitlab_token is defined
          - gitlab_token | length > 0
          - gitlab_user is defined
          - gitlab_user | length > 0
          - git_workdir is defined
          - git_workdir | length > 0
        fail_msg: "ERROR: Faltan variables de GitLab. Defínalas en AAP (Extra Vars, Survey o Credential)."
      when: do_push_gitlab | bool

    - name: Validar flags de control
      ansible.builtin.fail:
        msg: "Al menos uno de los flags debe estar activado: do_gitops, do_export_html o do_push_gitlab"
      when: not do_gitops and not do_export_html and not do_push_gitlab

    # ---------------------------------------------------------
    # 3. NORMALIZACIÓN DE DATOS (Sanitización)
    # ---------------------------------------------------------
    - name: Normalizar lista de clusters desde AAP
      ansible.builtin.set_fact:
        # AAP a veces envía la lista como string separado por comas o saltos de línea
        # Esto asegura que siempre tengamos una lista válida de Python
        target_clusters_list: "{{ survey_target_clusters.split('\n') if survey_target_clusters is string else survey_target_clusters }}"
      when: survey_target_clusters is defined

    - name: Inicializar lista vacía si no se definió survey_target_clusters
      ansible.builtin.set_fact:
        target_clusters_list: []
      when: survey_target_clusters is not defined

    # ---------------------------------------------------------
    # 4. DEBUG INFORMATIVO (Para ver qué recibió el playbook)
    # ---------------------------------------------------------
    - name: Mostrar configuración recibida (Sin secretos)
      ansible.builtin.debug:
        msg: |
          INICIO DE PIPELINE MULTI-CLUSTER
          ====================================
          Clusters:       {{ target_clusters_list }}
          GitOps:         {{ do_gitops }}
          Export HTML:    {{ do_export_html }}
          Push GitLab:    {{ do_push_gitlab }}
          User Git:       {{ github_user if (do_gitops and github_user is defined) else 'N/A' }}
          Branch:         {{ gitops_repo_branch if (do_gitops and gitops_repo_branch is defined) else 'N/A' }}
          GitLab Repo:    {{ gitlab_repo_url if (do_push_gitlab and gitlab_repo_url is defined) else 'N/A' }}
          Git Workdir:    {{ git_workdir if (do_push_gitlab and git_workdir is defined) else 'N/A' }}
          ====================================

    # ---------------------------------------------------------
    # 5. FASE GITOPS (Se ejecuta UNA vez al inicio)
    # ---------------------------------------------------------
    - name: Ejecutar Fase GitOps (Configuración Global)
      ansible.builtin.include_role:
        name: gitops_policy_update
      vars:
        # Pasar variables directamente del playbook
        # gitops_repo_path tiene default fijo en el rol, no necesita pasarse explícitamente
        # NO pasar variables de forma recursiva - el rol manejará los defaults
        github_token: "{{ github_token }}"
        github_user: "{{ github_user }}"
        gitops_repo_branch: "{{ gitops_repo_branch }}"
        # Estas variables se pasan solo si están definidas (el rol manejará defaults)
        run_cis: "{{ run_cis | default(true) | bool }}"
        run_pci: "{{ run_pci | default(false) | bool }}"
        scan_remediation_action: "{{ scan_remediation_action | default('inform') }}"
        install_operator_remediation_action: "{{ install_operator_remediation_action | default('enforce') }}"
        placement_label_key: "{{ placement_label_key | default('compliance') }}"
        placement_label_value: "{{ placement_label_value | default('enabled') }}"
        placement_use_matchlabels: "{{ placement_use_matchlabels | default(true) | bool }}"
        scan_schedule: "{{ scan_schedule | default('0 2 * * *') }}"
        scan_setting_name: "{{ scan_setting_name | default('periodic-daily') }}"
      when: do_gitops | bool

    # ---------------------------------------------------------
    # 6. FASE EXTRACCIÓN (Bucle por cada Cluster)
    # ---------------------------------------------------------
    - name: "Procesando extracción para {{ item }}"
      ansible.builtin.include_role:
        name: compliance_export_html
      vars:
        # INYECCIÓN DINÁMICA DE CONTEXTO - CRÍTICO: Usar item directamente sin default
        target_cluster_context: "{{ item }}"
        managed_cluster_name: "{{ item }}"
        # Mapear export_output_dir del playbook a compliance_reports_path del rol
        compliance_reports_path: "{{ export_output_dir | default('/tmp/compliance-reports') }}/{{ item }}"
      loop: "{{ target_clusters_list }}"
      loop_control:
        loop_var: item
        label: "Cluster: {{ item }}"
      when: 
        - do_export_html | bool
        - target_clusters_list | length > 0
        - item is defined
        - item | length > 0
      # RESILIENCIA: Si falla un cluster, sigue con el siguiente
      ignore_errors: true

    # ---------------------------------------------------------
    # 7. PUSH DE REPORTES A GITLAB (Clone -> Copiar -> Commit -> Push)
    # ---------------------------------------------------------
    - name: Buscar todos los ZIPs generados por cluster
      ansible.builtin.find:
        paths: "{{ export_output_dir }}"
        patterns: "*.zip"
        recurse: yes
        file_type: file
      register: all_zip_files
      when:
        - do_push_gitlab | bool
        - do_export_html | bool
        - target_clusters_list | length > 0

    - name: Construir lista de clusters procesados exitosamente
      ansible.builtin.set_fact:
        clusters_with_reports: "{{ all_zip_files.files | map(attribute='path') | map('regex_replace', '.*/([^/]+)/.*\\.zip$', '\\1') | list | unique }}"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    # URL con autenticación OAuth2 (token) para clone/push (no_log para no exponer token)
    - name: Construir URL de repositorio GitLab con autenticación
      ansible.builtin.set_fact:
        gitlab_repo_url_auth: "{{ 'https://oauth2:' ~ gitlab_token ~ '@' ~ (gitlab_repo_url | regex_replace('^https://', '')) }}"
      when: do_push_gitlab | bool
      no_log: true

    - name: Eliminar directorio de trabajo Git si existe (clone limpio)
      ansible.builtin.file:
        path: "{{ git_workdir }}"
        state: absent
      when: do_push_gitlab | bool

    - name: Clonar repositorio GitLab
      ansible.builtin.git:
        repo: "{{ gitlab_repo_url_auth }}"
        dest: "{{ git_workdir }}"
        version: "{{ gitlab_repo_branch | default('main') }}"
        force: true
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0
      no_log: true

    - name: Crear directorio de reportes dentro del repo
      ansible.builtin.file:
        path: "{{ git_workdir }}/reports"
        state: directory
        mode: "0755"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    - name: Copiar reportes ZIP al repositorio clonado
      ansible.builtin.copy:
        src: "{{ item.path }}"
        dest: "{{ git_workdir }}/reports/{{ item.path | basename }}"
        remote_src: true
        mode: "0644"
      loop: "{{ all_zip_files.files }}"
      loop_control:
        label: "{{ item.path | basename }}"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    - name: Configurar usuario Git para commit
      ansible.builtin.command:
        cmd: git config user.name "{{ gitlab_user }}"
        chdir: "{{ git_workdir }}"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    - name: Configurar email Git para commit
      ansible.builtin.command:
        cmd: git config user.email "{{ gitlab_user | default('ansible-bot') }}@users.noreply.gitlab.com"
        chdir: "{{ git_workdir }}"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    - name: Añadir archivos y hacer commit
      ansible.builtin.command:
        cmd: >
          git add reports/
          && git commit -m "{{ gitlab_commit_message | default('Compliance reports - ' ~ (clusters_with_reports | default([]) | join(', ')) ~ ' - ' ~ ansible_date_time.iso8601) }}"
        chdir: "{{ git_workdir }}"
      register: git_commit_result
      changed_when: "'nothing to commit' not in (git_commit_result.stderr | default(''))"
      failed_when: git_commit_result.rc != 0 and 'nothing to commit' not in (git_commit_result.stderr | default(''))
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0

    - name: Push a GitLab
      ansible.builtin.command:
        cmd: git push origin "{{ gitlab_repo_branch | default('main') }}"
        chdir: "{{ git_workdir }}"
      when:
        - do_push_gitlab | bool
        - all_zip_files is defined
        - all_zip_files.files | length > 0
        - git_commit_result is defined
        - git_commit_result.changed | default(false)
      no_log: true

    - name: Verificar resultado del push a GitLab
      ansible.builtin.debug:
        msg: "Reportes subidos a GitLab correctamente. Repo: {{ gitlab_repo_url }} (branch {{ gitlab_repo_branch | default('main') }})"
      when:
        - do_push_gitlab | bool
        - git_commit_result is defined

    # ---------------------------------------------------------
    # 8. RESUMEN FINAL
    # ---------------------------------------------------------
    - name: Resumen de ubicación de reportes
      ansible.builtin.debug:
        msg: |
          Los reportes se han guardado en: {{ export_output_dir }}/<nombre-cluster>/
          {% if do_push_gitlab | bool and all_zip_files is defined and all_zip_files.files | length > 0 %}
          Reportes subidos a GitLab: {{ gitlab_repo_url }} ({{ all_zip_files.files | length }} archivo(s) de {{ clusters_with_reports | default([]) | length }} cluster(s))
          {% elif do_push_gitlab | bool %}
          No se encontraron reportes para subir a GitLab
          {% endif %}
