---
# Rol: compliance_export_html
# Responsabilidad: Exportar resultados de compliance desde PVCs a HTML
# Se ejecuta desde el HUB y puede acceder a managed clusters usando kubeconfig

- name: Verificar que oc est√° disponible
  command: oc version --client
  register: oc_version
  changed_when: false
  failed_when: false

- name: Verificar si el kubeconfig est√° configurado
  shell: |
    oc config view --minify --raw 2>&1 || echo "NO_KUBECONFIG"
  register: kubeconfig_check
  changed_when: false
  failed_when: false
  when: oc_version.rc == 0

- name: Determinar si se puede usar oc para buscar secrets
  set_fact:
    can_use_oc: "{{ oc_version.rc == 0 and kubeconfig_check.stdout is defined and 'NO_KUBECONFIG' not in kubeconfig_check.stdout }}"
  when: oc_version.rc == 0

- name: Advertir si oc no est√° disponible o no tiene kubeconfig
  debug:
    msg: |
      ‚ö†Ô∏è  ADVERTENCIA: El comando 'oc' no est√° disponible o no tiene kubeconfig configurado.
      
      El playbook intentar√° usar m√©todos alternativos para obtener el kubeconfig:
      1. Secrets de ACM usando m√≥dulos de Ansible (si est√°n disponibles)
      2. Variables managed_cluster_kubeconfigs
      3. Archivos locales en /tmp/kubeconfig-*
      
      Si ejecutas desde AAP, aseg√∫rate de:
      - Configurar una credencial de tipo "OpenShift or Kubernetes API Bearer Token"
      - O configurar el kubeconfig en el proyecto de AAP
  when: oc_version.rc != 0 or (kubeconfig_check.stdout is defined and 'NO_KUBECONFIG' in kubeconfig_check.stdout)

- name: üîç DEBUG - Verificar contexto recibido
  debug:
    msg:
      - "=========================================="
      - "CONTEXTO RECIBIDO EN EL ROL"
      - "=========================================="
      - "target_cluster_context (raw): {{ target_cluster_context | default('NO_DEFINIDO') }}"
      - "managed_cluster_name (raw): {{ managed_cluster_name | default('NO_DEFINIDO') }}"
      - "inventory_hostname: {{ inventory_hostname }}"
      - "=========================================="

- name: Establecer variables iniciales b√°sicas
  set_fact:
    # CR√çTICO: No usar default('') aqu√≠ - si viene del orchestrator, debe tener valor
    # Si no viene definido, entonces s√≠ usar default
    target_cluster_context: "{{ target_cluster_context if target_cluster_context is defined else '' }}"
    managed_cluster_name: "{{ managed_cluster_name if managed_cluster_name is defined else (target_cluster_context if target_cluster_context is defined else '') }}"

- name: Establecer kubeconfig_secret_namespace (valor por defecto basado en managed_cluster_name)
  set_fact:
    kubeconfig_secret_namespace: "{{ managed_cluster_name if (target_cluster_context != '' and managed_cluster_name != '') else 'openshift-compliance' }}"

- name: Establecer managed_cluster_kubeconfigs (siempre usar diccionario vac√≠o por defecto)
  set_fact:
    _managed_cluster_kubeconfigs: "{{ {} }}"

- name: Establecer lista de nombres de secrets de ACM
  set_fact:
    acm_secret_names: "{{ ['admin-kubeconfig', managed_cluster_name + '-import', managed_cluster_name + '-bootstrap-sa-token'] }}"

- name: Buscar secret admin-kubeconfig en el Hub (Nativo - Prioridad 1)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ managed_cluster_name }}"
    name: admin-kubeconfig
  register: hub_admin_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Buscar secret de importaci√≥n (Fallback - Prioridad 2)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ managed_cluster_name }}"
    name: "{{ managed_cluster_name }}-import"
  register: hub_import_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Validar hallazgos de secrets
  set_fact:
    found_admin_secret: "{{ hub_admin_secret.resources | default([]) | length > 0 }}"
    found_import_secret: "{{ hub_import_secret.resources | default([]) | length > 0 }}"
  when: target_cluster_context != ''

- name: Extraer kubeconfig desde admin-kubeconfig (Prioridad 1)
  set_fact:
    kubeconfig_from_admin:
      stdout: "{{ hub_admin_secret.resources[0].data.kubeconfig | b64decode }}"
      rc: 0
      secret_namespace: "{{ hub_admin_secret.resources[0].metadata.namespace }}"
      secret_name: "{{ hub_admin_secret.resources[0].metadata.name }}"
  when:
    - target_cluster_context != ''
    - found_admin_secret | default(false) | bool
    - hub_admin_secret.resources | default([]) | length > 0
    - hub_admin_secret.resources[0].data.kubeconfig is defined

- name: Guardar kubeconfig desde admin-kubeconfig a archivo temporal
  copy:
    content: "{{ kubeconfig_from_admin.stdout }}"
    dest: "/tmp/kubeconfig-{{ managed_cluster_name }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - found_admin_secret | default(false) | bool
    - kubeconfig_from_admin.stdout is defined
    - kubeconfig_from_admin.stdout != ''
    - kubeconfig_from_admin.stdout | length > 100

- name: Extraer import.yaml del secret de importaci√≥n (Prioridad 2)
  set_fact:
    import_yaml_b64: "{{ hub_import_secret.resources[0].data['import.yaml'] }}"
    import_yaml_raw:
      stdout: "{{ hub_import_secret.resources[0].data['import.yaml'] | b64decode }}"
      rc: 0
  when:
    - target_cluster_context != ''
    - found_import_secret | default(false) | bool
    - hub_import_secret.resources[0].data['import.yaml'] is defined

- name: Inicializar variables si no se encontraron secrets
  set_fact:
    kubeconfig_from_admin:
      stdout: ""
      rc: 1
    import_yaml_raw:
      stdout: ""
      rc: 1
  when:
    - target_cluster_context != ''
    - not (found_admin_secret | default(false) | bool)
    - not (found_import_secret | default(false) | bool)

- name: Advertir si no se encontraron secrets de kubeconfig
  debug:
    msg: |
      ‚ö†Ô∏è  No se encontraron secrets de kubeconfig en el namespace '{{ managed_cluster_name }}'.
      
      Secrets buscados:
      1. admin-kubeconfig (prioridad alta)
      2. {{ managed_cluster_name }}-import (fallback)
      
      El playbook continuar√° con m√©todos alternativos:
      - Variables managed_cluster_kubeconfigs
      - Archivos locales en /tmp/kubeconfig-*
  when:
    - target_cluster_context != ''
    - not (found_admin_secret | default(false) | bool)
    - not (found_import_secret | default(false) | bool)

- name: Establecer ruta del archivo temporal import.yaml
  set_fact:
    import_yaml_file: "/tmp/import-{{ managed_cluster_name }}.yaml"
  when: target_cluster_context != ''

- name: Guardar import.yaml en archivo temporal
  copy:
    content: "{{ import_yaml_raw.stdout }}"
    dest: "{{ import_yaml_file }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100

- name: Crear script temporal para extraer kubeconfig
  template:
    src: extract-kubeconfig.sh.j2
    dest: "/tmp/extract-kubeconfig-{{ managed_cluster_name }}.sh"
    mode: '0755'
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100

- name: Extraer kubeconfig desde bootstrap-hub-kubeconfig en import.yaml
  command: "/tmp/extract-kubeconfig-{{ managed_cluster_name }}.sh {{ import_yaml_file }}"
  register: kubeconfig_from_import
  changed_when: false
  failed_when: false
  when:
    - target_cluster_context != ''
    - import_yaml_raw.stdout is defined
    - import_yaml_raw.stdout | length > 100


- name: Determinar kubeconfig final desde secrets de ACM (priorizar admin-kubeconfig sobre bootstrap-hub-kubeconfig)
  set_fact:
    kubeconfig_from_acm_secret: "{{ kubeconfig_from_admin if (kubeconfig_from_admin.stdout is defined and kubeconfig_from_admin.stdout != '' and kubeconfig_from_admin.stdout | length > 100) else (kubeconfig_from_import if (kubeconfig_from_import.stdout is defined and kubeconfig_from_import.stdout != '' and kubeconfig_from_import.stdout | length > 100) else {'rc': 1, 'stdout': ''}) }}"
  when: target_cluster_context != ''

- name: Buscar kubeconfig en secret personalizado (fallback)
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ kubeconfig_secret_namespace }}"
    name: "managed-cluster-kubeconfig-{{ managed_cluster_name }}"
  register: hub_custom_secret
  when: target_cluster_context != ''
  ignore_errors: true

- name: Extraer kubeconfig desde secret personalizado
  set_fact:
    kubeconfig_from_custom_secret:
      stdout: "{{ hub_custom_secret.resources[0].data.kubeconfig | b64decode }}"
      rc: 0
  when:
    - target_cluster_context != ''
    - hub_custom_secret.resources | default([]) | length > 0
    - hub_custom_secret.resources[0].data.kubeconfig is defined

- name: Marcar kubeconfig personalizado como no encontrado
  set_fact:
    kubeconfig_from_custom_secret:
      stdout: ""
      rc: 1
  when:
    - target_cluster_context != ''
    - hub_custom_secret.resources | default([]) | length == 0

- name: Determinar qu√© secret se us√≥
  set_fact:
    kubeconfig_from_secret: "{{ kubeconfig_from_acm_secret if (kubeconfig_from_acm_secret.rc == 0 and kubeconfig_from_acm_secret.stdout != '' and kubeconfig_from_acm_secret.stdout | length > 100) else (kubeconfig_from_custom_secret if (kubeconfig_from_custom_secret.rc == 0 and kubeconfig_from_custom_secret.stdout != '' and kubeconfig_from_custom_secret.stdout | length > 100) else {'rc': 1, 'stdout': ''}) }}"
    secret_source: "{{ 'admin_kubeconfig' if (kubeconfig_from_admin.stdout is defined and kubeconfig_from_admin.stdout != '' and kubeconfig_from_admin.stdout | length > 100) else ('bootstrap_hub_kubeconfig' if (kubeconfig_from_import.stdout is defined and kubeconfig_from_import.stdout != '' and kubeconfig_from_import.stdout | length > 100) else ('custom' if (kubeconfig_from_custom_secret.rc == 0 and kubeconfig_from_custom_secret.stdout != '' and kubeconfig_from_custom_secret.stdout | length > 100) else 'none')) }}"
  when: target_cluster_context != ''

- name: Guardar kubeconfig desde secret a archivo temporal
  copy:
    content: "{{ kubeconfig_from_secret.stdout }}"
    dest: "/tmp/kubeconfig-{{ managed_cluster_name }}"
    mode: '0600'
  when:
    - target_cluster_context != ''
    - secret_source != 'none'
    - kubeconfig_from_secret.stdout is defined
    - kubeconfig_from_secret.stdout != ''
    - kubeconfig_from_secret.stdout | length > 100

- name: Determinar ruta del kubeconfig del managed cluster (fallback a archivo local)
  set_fact:
    managed_cluster_kubeconfig_path: "{{ ('/tmp/kubeconfig-' + managed_cluster_name) if (target_cluster_context != '' and secret_source != 'none') else (_managed_cluster_kubeconfigs[managed_cluster_name] if (target_cluster_context != '' and _managed_cluster_kubeconfigs is defined and managed_cluster_name in _managed_cluster_kubeconfigs) else ('/tmp/kubeconfig-' + managed_cluster_name if target_cluster_context != '' else '')) }}"
    oc_context_arg: ""
    is_managed_cluster: "{{ target_cluster_context != '' }}"
    kubeconfig_source: "{{ secret_source if (target_cluster_context != '' and secret_source != 'none') else ('file' if (target_cluster_context != '' and _managed_cluster_kubeconfigs is defined and managed_cluster_name in _managed_cluster_kubeconfigs) else ('default_file' if target_cluster_context != '' else 'none')) }}"
  when: target_cluster_context != ''

- name: Verificar si existe kubeconfig en archivo (fallback)
  stat:
    path: "{{ managed_cluster_kubeconfig_path }}"
  register: kubeconfig_exists
  when:
    - target_cluster_context != ''
    - managed_cluster_kubeconfig_path != ''
    - kubeconfig_source is defined
    - kubeconfig_source != 'acm_native'
    - kubeconfig_source != 'custom'

- name: Verificar validez del kubeconfig
  shell: |
    KUBECONFIG="{{ managed_cluster_kubeconfig_path }}" oc whoami &>/dev/null && echo "valid" || echo "invalid"
  register: kubeconfig_validity
  changed_when: false
  failed_when: false
  when:
    - target_cluster_context != ''
    - (kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists)

- name: Advertir si el kubeconfig est√° expirado
  debug:
    msg: |
      ‚ö†Ô∏è  El kubeconfig para '{{ target_cluster_context }}' est√° expirado o inv√°lido.
      
      {% if kubeconfig_source == 'acm_native' %}
      El kubeconfig viene de un secret nativo de ACM (admin-kubeconfig o {{ managed_cluster_name }}-import).
      ACM deber√≠a renovarlo autom√°ticamente. Si persiste el problema, verifica:
        oc get secret admin-kubeconfig -n {{ managed_cluster_name }}
        oc get secret {{ managed_cluster_name }}-import -n {{ managed_cluster_name }}
      {% elif kubeconfig_source == 'custom' %}
      Para renovarlo, actualiza el secret personalizado:
        ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }}
      {% else %}
      Para renovarlo:
      1. Loguearte al managed cluster: oc login <api-server-url>
      2. Exportar nuevo kubeconfig: oc config view --minify --raw > {{ managed_cluster_kubeconfig_path }}
      3. Ajustar permisos: chmod 600 {{ managed_cluster_kubeconfig_path }}
      4. (Opcional) Guardar en secret: ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }} {{ managed_cluster_kubeconfig_path }}
      {% endif %}
  when:
    - target_cluster_context != ''
    - (kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists)
    - kubeconfig_validity.stdout == "invalid"

- name: Fallar si no se puede acceder al managed cluster
  fail:
    msg: |
      ‚ùå No se encontr√≥ kubeconfig para el managed cluster '{{ target_cluster_context }}'.
      
      El playbook busc√≥ en:
      1. Secrets nativos de ACM en namespace '{{ managed_cluster_name }}':
         - admin-kubeconfig
         - {{ managed_cluster_name }}-import
         - Cualquier secret con "kubeconfig" en el nombre
      
      2. Secret personalizado: managed-cluster-kubeconfig-{{ managed_cluster_name }} en namespace '{{ kubeconfig_secret_namespace }}'
      
      3. Variable managed_cluster_kubeconfigs
      
      4. Archivo: /tmp/kubeconfig-{{ target_cluster_context }}
      
      Soluciones:
      - Verificar que el namespace '{{ managed_cluster_name }}' existe: oc get namespace {{ managed_cluster_name }}
      - Listar secrets disponibles: oc get secrets -n {{ managed_cluster_name }}
      - Si no hay secret nativo, crear uno: ./scripts/crear-secret-kubeconfig.sh {{ target_cluster_context }}
      - Si los PVCs est√°n en el Hub, no especifiques target_cluster_context
  when:
    - target_cluster_context != ''
    - not ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))

- name: Mostrar m√©todo de acceso al cluster
  debug:
    msg: |
      ========================================
      M√©todo de Acceso al Cluster
      ========================================
      üåç Cluster/Ambiente: {{ managed_cluster_name if target_cluster_context != '' else 'HUB (contexto actual)' }}
      üìç Fuente: {{ kubeconfig_source if target_cluster_context != '' else 'Contexto actual (HUB)' }}
      üîë Kubeconfig: {{ managed_cluster_kubeconfig_path if (target_cluster_context != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else 'Contexto actual (HUB)' }}
      {% if kubeconfig_source == 'acm_native' %}
      üì¶ Secret nativo de ACM en namespace: {{ managed_cluster_name }}
      üîç Secrets buscados: admin-kubeconfig, {{ managed_cluster_name }}-import
      {% elif kubeconfig_source == 'custom' %}
      üì¶ Secret personalizado: managed-cluster-kubeconfig-{{ managed_cluster_name }} en namespace {{ kubeconfig_secret_namespace }}
      {% endif %}
      ========================================
  when: target_cluster_context != ''

- name: Verificar que oscap est√° disponible
  command: oscap --version
  register: oscap_check
  changed_when: false
  failed_when: false

- name: Fallar si oscap no est√° disponible
  fail:
    msg: "oscap (openscap-scanner) no est√° disponible. Instalar con: yum install openscap-scanner"
  when: oscap_check.rc != 0

- name: Verificar que bzip2 est√° disponible
  command: which bunzip2 || which bzip2
  register: bzip2_check
  changed_when: false
  failed_when: false

- name: Advertir si bzip2 no est√° disponible
  debug:
    msg: "Advertencia: bunzip2/bzip2 no est√° disponible. Los archivos .bzip2 no se podr√°n descomprimir autom√°ticamente."
  when: bzip2_check.rc != 0

- name: Verificar que zip est√° disponible
  command: which zip
  register: zip_check
  changed_when: false
  failed_when: false

- name: Advertir si zip no est√° disponible
  debug:
    msg: "Advertencia: zip no est√° disponible. No se podr√° crear el archivo ZIP. Instalar con: sudo apt-get install zip"
  when: zip_check.rc != 0

- name: Crear directorio de salida (organizado por cluster)
  file:
    path: "{{ compliance_reports_path }}"
    state: directory
    mode: '0755'
    recurse: yes

- name: Buscar PVCs de compliance
  command: oc get pvc -n openshift-compliance {{ oc_context_arg | default('') }} --no-headers -o custom-columns=NAME:.metadata.name
  register: pvc_list
  changed_when: false
  environment: "{{ {'KUBECONFIG': managed_cluster_kubeconfig_path} if (target_cluster_context != '' and managed_cluster_kubeconfig_path is defined and managed_cluster_kubeconfig_path != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else {} }}"

- name: Filtrar PVCs CIS y PCI
  set_fact:
    cis_pvcs: "{{ pvc_list.stdout_lines | select('match', '^ocp4-cis.*') | list }}"
    pci_pvcs: "{{ pvc_list.stdout_lines | select('match', '^ocp4-pci-dss.*') | list }}"

- name: Mostrar PVCs encontrados
  debug:
    msg: |
      ========================================
      PVCs Encontrados en {{ managed_cluster_name if target_cluster_context != '' else 'HUB' }}
      ========================================
      üìä PVCs CIS: {{ cis_pvcs | length }} - {{ cis_pvcs if cis_pvcs | length > 0 else 'Ninguno' }}
      üìä PVCs PCI: {{ pci_pvcs | length }} - {{ pci_pvcs if pci_pvcs | length > 0 else 'Ninguno' }}
      ========================================
      
      ‚ö†Ô∏è  VERIFICACI√ìN: Aseg√∫rate de que estos nombres coincidan con los PVCs que inspeccionaste manualmente.
      Si no coinciden, verifica que los scans de compliance hayan completado correctamente.

- name: Establecer valores finales para sub-tareas
  set_fact:
    _final_managed_cluster_kubeconfig_path: "{{ managed_cluster_kubeconfig_path if (target_cluster_context != '' and managed_cluster_kubeconfig_path is defined and managed_cluster_kubeconfig_path != '' and ((kubeconfig_source in ['acm_native', 'custom']) or (kubeconfig_exists.stat.exists))) else '' }}"
    _final_oc_context_arg: "{{ oc_context_arg | default('') }}"

- name: Procesar cada PVC CIS
  when: cis_pvcs | length > 0
  include_tasks: process_pvc.yml
  loop: "{{ cis_pvcs }}"
  loop_control:
    loop_var: pvc_item
    label: "{{ pvc_item }}"
  vars:
    pvc_name: "{{ pvc_item }}"
    pvc_type: "cis"
    oc_context_arg: "{{ _final_oc_context_arg }}"
    managed_cluster_kubeconfig_path: "{{ _final_managed_cluster_kubeconfig_path }}"

- name: Procesar cada PVC PCI
  when: pci_pvcs | length > 0
  include_tasks: process_pvc.yml
  loop: "{{ pci_pvcs }}"
  loop_control:
    loop_var: pvc_item
    label: "{{ pvc_item }}"
  vars:
    pvc_name: "{{ pvc_item }}"
    pvc_type: "pci"
    oc_context_arg: "{{ _final_oc_context_arg }}"
    managed_cluster_kubeconfig_path: "{{ _final_managed_cluster_kubeconfig_path }}"

# --- TAREAS DE PREPARACI√ìN DE DATOS (Descomprimir y Aplanar) ---

- name: Descomprimir archivos .bzip2 (Recursivo en todas las carpetas de PVC)
  shell: |
    find "{{ compliance_reports_path }}" -type d -name "ocp4-*" | while read pvc_dir; do
      if [ -d "$pvc_dir" ]; then
        echo "Descomprimiendo archivos en: $pvc_dir"
        find "$pvc_dir" -name "*.bzip2" -exec bunzip2 -f {} \; 2>/dev/null || true
      fi
    done
  args:
    executable: /bin/bash
  ignore_errors: true
  register: decompression_result

- name: Aplanar estructura de directorios (Mover XMLs de subdirectorios a la ra√≠z de cada PVC)
  shell: |
    find "{{ compliance_reports_path }}" -type d -name "ocp4-*" | while read pvc_dir; do
      if [ -d "$pvc_dir" ]; then
        echo "Aplanando XMLs en: $pvc_dir"
        # Buscar XMLs en subdirectorios (mindepth 2) y moverlos a la ra√≠z del PVC
        find "$pvc_dir" -name "*.xml" -mindepth 2 -type f -exec mv {} "$pvc_dir/" \; 2>/dev/null || true
      fi
    done
  args:
    executable: /bin/bash
  ignore_errors: true
  register: flatten_result

- name: Renderizar script de conversi√≥n XML ‚Üí HTML
  template:
    src: render_reports.sh.j2
    dest: "{{ compliance_reports_path }}/render_reports.sh"
    mode: '0755'

- name: Ejecutar conversi√≥n XML ‚Üí HTML
  command: "{{ compliance_reports_path }}/render_reports.sh"
  args:
    chdir: "{{ compliance_reports_path }}"
  register: render_script_output
  changed_when: render_script_output.rc == 0
  failed_when: false

- name: Verificar archivos HTML generados
  find:
    paths: "{{ compliance_reports_path }}"
    patterns: "*.html"
    recurse: true
  register: html_files

# ‚ùå COMENTADO: Limpieza de archivos deshabilitada para permitir adjuntar archivos por correo
# Los archivos se mantienen para que puedan ser adjuntados en el correo electr√≥nico
# - name: Limpiar archivos intermedios
#   block:
#     - name: Eliminar archivos .bzip2
#       find:
#         paths: "{{ compliance_reports_path }}"
#         patterns: "*.bzip2"
#         recurse: true
#       register: bzip2_files
#
#     - name: Eliminar archivos .bzip2 encontrados
#       file:
#         path: "{{ item.path }}"
#         state: absent
#       loop: "{{ bzip2_files.files }}"
#       when: bzip2_files.files | length > 0
#
#     - name: Eliminar archivos .bzip2.out
#       find:
#         paths: "{{ compliance_reports_path }}"
#         patterns: "*.bzip2.out"
#         recurse: true
#       register: bzip2_out_files
#
#     - name: Eliminar archivos .bzip2.out encontrados
#       file:
#         path: "{{ item.path }}"
#         state: absent
#       loop: "{{ bzip2_out_files.files }}"
#       when: bzip2_out_files.files | length > 0
#
#     - name: Eliminar archivos .xml
#       find:
#         paths: "{{ compliance_reports_path }}"
#         patterns: "*.xml"
#         recurse: true
#       register: xml_files
#
#     - name: Eliminar archivos XML encontrados
#       file:
#         path: "{{ item.path }}"
#         state: absent
#       loop: "{{ xml_files.files }}"
#       when: xml_files.files | length > 0
#
#     - name: Eliminar script temporal
#       file:
#         path: "{{ compliance_reports_path }}/render_reports.sh"
#         state: absent
#
#     - name: Eliminar directorios lost+found
#       find:
#         paths: "{{ compliance_reports_path }}"
#         patterns: "lost+found"
#         file_type: directory
#         recurse: true
#       register: lost_found_dirs
#
#     - name: Eliminar directorios lost+found encontrados
#       file:
#         path: "{{ item.path }}"
#         state: absent
#       loop: "{{ lost_found_dirs.files }}"
#       ignore_errors: true

- name: Generar summary.txt
  template:
    src: summary.txt.j2
    dest: "{{ compliance_reports_path }}/summary.txt"
    mode: '0644'
  vars:
    cis_pvcs: "{{ cis_pvcs }}"
    pci_pvcs: "{{ pci_pvcs }}"
    compliance_reports_path: "{{ compliance_reports_path }}"

# --- VERIFICACI√ìN DE DEBUG (Para saber por qu√© no llega el correo) ---
- name: üêõ DEBUG - Estado previo al correo
  debug:
    msg:
      - "Variable do_send_email: {{ do_send_email }}"
      - "Variable email_to: {{ email_to }}"
      - "Ruta de reportes: {{ compliance_reports_path }}"
      - "Cluster context: {{ target_cluster_context | default(inventory_hostname) }}"

# --- EMPAQUETADO (Soluci√≥n para evitar l√≠mite de tama√±o de Gmail) ---

- name: Buscar archivos HTML y summary para comprimir
  find:
    paths: "{{ compliance_reports_path }}"
    patterns: 
      - "*.html"       # Solo HTMLs (excluimos XML pesados)
      - "summary.txt"   # El resumen
    recurse: yes        # Busca en todas las subcarpetas (3/, 4/, 5/, etc.)
    file_type: file
  register: files_to_zip
  when: do_send_email | bool

- name: Comprimir reportes HTML y Resumen en un ZIP
  community.general.archive:
    path: "{{ files_to_zip.files | map(attribute='path') | list }}"
    dest: "{{ compliance_reports_path }}/compliance_reports_{{ target_cluster_context | default(inventory_hostname) }}_{{ ansible_date_time.epoch }}.zip"
    format: zip
    mode: '0644'
  register: zip_creation
  when: 
    - do_send_email | bool
    - files_to_zip is defined
    - files_to_zip.files | length > 0

  when: 
    - do_send_email | bool
    - zip_creation is defined

# --- ENV√çO DE CORREO OPTIMIZADO ---

- name: Enviar reporte de Compliance (ZIP) por correo electr√≥nico
  community.general.mail:
    host: "{{ email_smtp_host }}"
    port: "{{ email_smtp_port }}"
    username: "{{ email_smtp_username }}"
    password: "{{ email_smtp_password }}"
    from: "{{ email_from }}"
    to: "{{ email_to }}"
    subject: "{{ email_subject_prefix }} - Cluster: {{ target_cluster_context | default(inventory_hostname) }} (Reporte Completo)"
    body: |
      Hola,
      
      Se adjunta el reporte de cumplimiento consolidado.
      
      üì¶ Contenido del ZIP:
      - Reportes detallados en formato HTML ({{ files_to_zip.files | selectattr('path', 'match', '.*\\.html$') | list | length }} archivos).
      - Resumen de ejecuci√≥n (summary.txt).
      
      Nota: Los archivos XML crudos permanecen en el servidor para auditor√≠a si fueran necesarios.
      
      Saludos,
      Equipo de Automatizaci√≥n.
    # ADJUNTAMOS SOLO EL ZIP
    attach:
      - "{{ zip_creation.dest }}"
    secure: starttls
  delegate_to: localhost
  when: 
    - do_send_email | bool
    - zip_creation is defined
    - zip_creation.state == 'file'
  ignore_errors: true # Para ver el error SMTP si falla la contrase√±a
